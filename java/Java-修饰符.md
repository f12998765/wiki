# Java 修饰符
## 分类

* 访问修饰符 `public`、`private`、`protected`、default

* 非访问修饰符 `static`、`final`、`abstract`、`synchronized`、`transient`、`volatile`


## 访问修饰符

**保护对类、变量、方法和构造方法的访问**

### 公有访问修饰符 -- public

* 被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问

* 不同的包中，则需要导入相应 public 类所在的包。

* 由于类的继承性，类所有的公有方法和变量都能被其子类继承


### 私有访问修饰符 -- private

* 被声明为 private 的方法、变量和构造方法只能被所属类访问

* 类和接口不能声明为 private

* 声明为私有访问类型的变量只能通过类中公共的 Getter\/Setter 方法被外部类访问


### 保护访问修饰符 -- protected

* 被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。

* Protected 访问修饰符不能修饰类和接口，方法和成员变量能够声明为 protected，但是接口的成员变量和成员方法不能声明为 protected

* 子类能访问 Protected 修饰符声明的方法和变量


### 默认访问修饰符

* 使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的

* 接口里的变量都隐式声明为 public static final, 而接口里的方法默认情况下访问权限为 public


### 权限比较

|访问修饰符|所属类|所属包的其他类|子类|其他包的其他类|
|:-:|:-:|:-:|:-:|:-:|
|public|O|O|O|O|
|protected|O|O|O|X|
|default|O|O|X|X|
|private|O|X|X|X|

### 访问控制与继承

**继承中，子类的权限不能小于父类的。**

* 父类中声明为 public 的方法在子类中也必须为 public。

* 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public。

* 父类中默认修饰符声明的方法，能够在子类中声明为 protected。

* 父类中声明为 private 的方法，不能够被继承。


## 非访问修饰符

### static 修饰符

**被 static 修饰的成员变量和成员方法独立于该类的任何对象，被所有对象共享。**

#### 静态变量

**用static修饰的成员变量称为静态变量，其他的称为实例变量**

静态变量在加载类的过程中完成空间分配，只有一份拷贝，可以直接用类名访问。

实例变量在对象实例化时分配内存。

#### 静态方法

**静态方法中不能用 this 和 super 关键字，不能直接访问所属类的实例变量和实例方法，只能访问所属类的静态成员变量和成员方法**

不可继承

#### 静态代码块

请看代码块相关内容。

#### 静态导入

```java
// 导入某个特定的静态方法
import static packageName.className.methonName;

// 导入类中的所有静态成员
import static packageName.className.*;
```

可以在当前类中直接用方法名调用静态方法，不必再通过类名来访问。

### final 修饰符

**最终的，不可改变**

#### final 变量

final 变量即常量，仅可以赋值一次。

final 修饰的成员变量，要显示初始化，如果没有只能在构造函数中进行一次赋值

当变量为引用类型的时候，不可以改变引用对象，但可以改变对象的属性等。

#### final 方法

final 可以被子类调用，但不可以重写。

#### final 类

final 类不可继承。

#### final static

成员变量，必须显示初始化，不可以修改，成员方法不可覆盖，可以通过类名直接访问。

### Abstract 修饰符

用来定义抽象方法和抽象类。

**abstract 不可以 与 final , private , static 共存**

1. Abstract 修饰后，必须通过类继承或者接口实现来重写，否则就是摆设。

2. final 修饰的类 \ 方法 \ 属性均不可再次更改，故而不可以被重写。

3. private 修饰的类只可以定义在内部类；private 修饰的方法 \ 属性只可以在类中调用，重写时是访问不到这些方法和属性的。

4. static 静态的，其修饰的方法 \ 属性，是随着类的创建而创建，类的消亡而消亡，在编译时就已经确定的东西；但是 abstract 是 dynamic（动态）的，其必须通过类继承或接口实现来动态重写 abstract 方法。


### Synchronized 修饰符

Synchronized 关键字声明的方法同一时间只能被一个线程访问

### Transient 修饰符

序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机 \(JVM\) 跳过该特定的变量。

该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

### Volatile 修饰符

Volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。

一个 volatile 对象引用可能是 null。

# Java 类与对象

## 什么是类？

**类是实体的抽象，对象是类的实例化。**

```java

访问修饰符 class 类名{

 //成员变量

 //构造方法

 //成员方法

}

```

## 变量的类型、作用域和生存期

| 类型 | 定义 | 作用域 | 生存期 | 初始值 |
| --- | --- | --- | --- | --- |
| 成员变量 | 实体的属性，在类中声明，但是它方法、构造器或者语句块外 | 当前类 | 随对象的创建而创建， 随对象销毁而销毁 | 默认初始值：数字 -- &gt; 0，布尔型 --&gt; `false`，对象引用 --&gt; null |
| 局部变量 | 定义在方法、语句块中的变量以及形参 | 局部有效 | 作用范围结束，就会释放空间 | 没有默认初始值，使用时必须赋值 |
| 静态变量 / 类变量 | 用关键字static修饰的成员变量 | 多个对象共享一个变量 | 随着类的加载而存在，随着类的消失而消失 | 可用类名或对象名访问；有初始默认值 |

## 成员方法

**方法是实体的功能实现**

```java

访问修饰符 返回值类型 函数名(参数类型 参数名) {

 //执行语句

 return 返回值;

}

```

### 方法的重载

可以是一个类中，也可以是继承中。

父类的方法定义为 `private` 时，子类可以定义相同方法，是新的方法，**不是重载也不是重写**，是子类的扩展方法。

* 相同的方法名，不同**参数的类型、参数的个数和参数的顺序**

* **返回值、访问修饰符、抛出异常**与方法的重载无关。

重写是子类实现覆盖父类的方法。

### 不定参数

使用 `...` 可以定义不定参数的方法，在方法中以数组的方式使用

```java
public void get(String ... name){
    System.out.println(name[0]);
}
```

### 含有不定参数的方法重载

#### 与数组参数
由于不定参数的处理方法与数组参数类似，是个语法糖，他们两个是**相同的方法**，不能在一同定义。

但是仍然有区别，**数组参数只能传入数组变量**，不定参数传入的是非负个元素。

```java
void get(String... s){}
void get(String[] s){}
```
#### 与固定参数和无参数

存在**固定参数或无参数**的方法时，优先不定参数方法使用。

```java
void get(){}
void get(String s){}
void get(String... s){}
```

#### 与不定参数类型相同的固定参数

注意以下情况，虽然编写方法是不报错，但是调用时会提示，**与两种方法都匹配**，所以不能写成这样。

```java
void get(String... s){}
void get(String v,String... s){}
```
不管传入几个参数，两个方法都匹配，可以如下修改，目的是使得不会匹配多个方法。

```java
void get(int v,String... s){}
void get(int v,String v,String... s){}
```

## 构造方法

**在类实例化过程中有且仅调用一次的无返回值方法，对对象进行初始化。**

特点

* 方法名**与类名相同**

* 不可以显示调用

* **不需要**定义返回值类型，没有返回值


> a.没有定义构造函数时，会自动生成无参构造函数，否则不会生成。
>
> b.多个构造函数是重载的体现。


## 对象

**对象是类的实例化**


```java
ClasaName name=new ClassName();
```

* 对象的创建 :

  * 声明变量 --&gt; 实例化 --&gt; 初始化

* 执行顺序（优先级从高到低）：

  * 静态代码块&gt;mian方法&gt;构造代码块&gt;构造方法


## 创建一个对象都在内存中做了什么事情？

1. 加载硬盘中`.class` 文件到内存

2. `main()`执行时，在栈内存中创建`main()`的空间\(压栈-入栈\)，`main()`的栈区中创建变量

3. `new`在堆内存中创建实体空间

4. 在实体空间中进行属性的空间分配，并且进行默认初始化

5. 对属性进行显示初始化，即对其赋值

6. 进行实体的构造代码块初始化

7. 调用该实体对应的构造函数，进行构造函数初始化

8. 将实体空间首地址赋值给变量，变量就引用了该实体，即指向了该对象

## 代码块

**用{ }封装的多行代码**

| 代码块 | 定义 | 特性 |
| --- | --- | --- |
| 普通代码块 | 方法或语句中出现的代码块 | 按顺序执行，最小作用域 |
| 构造代码块 | 在类中的未用static修饰的代码块 | 对变量赋值，执行语句。创建对象时执行，早于构造函数 |
| 静态代码块 | 在类中用static修饰的代码块 | 仅会在第一次对象实例化时创建执行 |

## 类初始化顺序
### 一般类
1. 静态变量
2. 静态代码块
3. 成员变量
4. 构造代码块
5. 构造器
### 继承
1. 父类静态成员函数 -->父类静态变量 -->父类静态代码块
2. 子类静态成员函数 --> 子类静态变量 -->子类静态代码块
3. 父类成员函数 --> 父类变量 --> 父类构造代码块 --> 父类构造器
4. 子类成员函数 --> 子类变量 --> 子类构造代码块 --> 子类构造器

## 对象的拷贝

直接赋值给对象的引用，其实是两个引用指向了同一个对象。想要复制一个对象，需要使用 Object 的 clone() 方法。会创建一个新的对象，而且对象的状态与被拷贝对象的状态相同。

无论目标类是否实现了Cloneable接口，只要调用到了Object.clone()，比如通过super.clone()，那么就必须处理或者抛出`CloneNotSupportedException`，因为Object.clone()有throws这个异常，有抛的就必然有接的。

拷贝的类必须 `implements` `Cloneable` 接口(标志)，否则会报 `CloneNotSupportedException` 异常。

浅拷贝和深拷贝的区别，在于成员对象变量是否是同一个对象的引用。多级对象的深拷贝，需要在调用对象中实现`clone()`并且调用。否则，只是简单地赋值，即浅拷贝。

拷贝需要重写 `Object` 类的 `clone()` 方法，并将访问权限变成 `public`。如果不改变权限，在不同的包中，就不能使用。记住，`protected` 继承时，不同包，只能在子类中运行。

```java
protected Object clone() throws CloneNotSupportedException {       
    return super.clone();                                          
}                                                                  
```

使用 `clone` 进行深拷贝，比较复杂，需要每个调用类实现接口，直到成员中没有对象引用。使用序列化，比较方便。更多，请看 java 序列化。

## Object：equals()、hashCode()、toString()
### equals()

逻辑等价性
- 自反：a.quals(a)==ture
- 对称：a.equals(b)==b.equals(a)
- 传递：a.equals(b)==ture; b.equals(c)==ture; --> a.equals(c)==true;
- 非空：a.equals(null)==flase; **重要**

与 `==` 的区别
- 对于基本类型，== 比较两个数的值，equals 不能使用
- 对于对象，没有重写的与 == 相同，比较的是地址，重写后的equals 比较的是内容
- 对于 String，== 比较的是地址，被重写后的 equals 比较字符串

### hashCode()

获取对象的哈希码，哈希码是用来确定对象在哈希表中的索引位置

创建 类对应的散列表 的类，例如，HashSet、HashTable、HashMap

在**不会**创建 类对应的散列表 的类中，hashCode 和 equals 没有关系。

在创建 类对应的散列表 的类中，首先，这里的相等等于equals的结果为 true
- 两个对象相等，hashCode() 值相同
- hashCode() 相同，并不一定相等

**此时，判断两个对象相等，不仅仅重写 equals，还要重写 hashCode()**

判断能否放入 HashSet，首先判断 hashCode() ，不相等放入，相等判断 equals() ，fasle 放入，true 不放。

[Java hashCode() 和 equals()的若干问题解答](http://www.cnblogs.com/skywang12345/p/3324958.html)
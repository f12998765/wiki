# 排序总结

## 代码速览

- [冒泡排序](https://github.com/f12998765/Algorithm/blob/8192d351638e9d914fbe26bb2d3c2544cef5ceff/sort.c#L17-L37)
- [选择排序](https://github.com/f12998765/Algorithm/blob/8192d351638e9d914fbe26bb2d3c2544cef5ceff/sort.c#L39-L47)
- [插入排序](https://github.com/f12998765/Algorithm/blob/8192d351638e9d914fbe26bb2d3c2544cef5ceff/sort.c#L49-L86)
- [归并排序](https://github.com/f12998765/Algorithm/blob/8192d351638e9d914fbe26bb2d3c2544cef5ceff/sort.c#L99-L141)
- [快速排序](https://github.com/f12998765/Algorithm/blob/8192d351638e9d914fbe26bb2d3c2544cef5ceff/sort.c#L143-L194)
- [希尔排序](https://github.com/f12998765/Algorithm/blob/8192d351638e9d914fbe26bb2d3c2544cef5ceff/sort.c#L195-L202)
- [堆排序](https://github.com/f12998765/Algorithm/blob/8192d351638e9d914fbe26bb2d3c2544cef5ceff/sort.c#L204-L243)
- [计数排序](https://github.com/f12998765/Algorithm/blob/8192d351638e9d914fbe26bb2d3c2544cef5ceff/sort.c#L245-L266)
- [桶排序](https://github.com/f12998765/Algorithm/blob/8192d351638e9d914fbe26bb2d3c2544cef5ceff/sort.c#L267-L327)
- [基数排序](https://github.com/f12998765/Algorithm/blob/8192d351638e9d914fbe26bb2d3c2544cef5ceff/sort.c#L328-L350)



## 分类

1. 按比较和非比较分，计数排序、桶排序、基数排序是非比较排序（特点是线性时间复杂度），其他都是比较排序
2. 按稳定和非稳定分
   - 稳定：冒泡排序、插入排序、归并排序、非比较排序
   - 非稳定：选择排序、快速排序、希尔排序、堆排序

## 复杂度

| 方法   | 最好     | 平均     | 最坏     | 空间    | 稳定性 |
| ------ | -------- | -------- | -------- | ------- | ------ |
| 冒泡   | O(n)     | O(n^2)   | O(n^2)   | O(1)    | 稳定   |
| 插入   | O(n)     | O(n^2)   | O(n^2)   | O(1)    | 稳定   |
| 归并   | O(nlogn) | O(nlogn) | O(nlogn) | O(n)    | 稳定   |
| 计数   | O(n+k)   | O(n+k)   | O(n+k)   | O(n+k)  | 稳定   |
| 桶排序 | O(n+k)   | O(n+k)   | O(n+k)   | O(n+k)  | 稳定   |
| 基数   | O(n)     | O(n)     | O(n)     | O(n)    | 稳定   |
| 选择   | O(n^2)   | O(n^2)   | O(n^2)   | O(1)    | 不稳定 |
| 快速   | O(nlogn) | O(nlogn) | O(n^2)   | O(logn) | 不稳定 |
| 希尔   |          |          |          | O(1)    | 不稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1)    | 不稳定 |



## 思想实现

### 冒泡排序

从左向右冒泡，即左右相邻的元素比较，讲最大值移向右边，直到这一数组的最大值到达最右，一趟结束，进行下一趟找到未排列数组的最大值，重复。

实现的时候优化一下使用标志 flag ，标志这趟是否发生过交换，即数组是不是有序的，这样就可以不用重复比较有序的数组了。

**时间复杂度**，最坏复杂度是O(n^2)，最好复杂度是O(n)，因为排序数组是有序的时候，只要遍历一遍，根据 flag 就能直到他是有序的。

**稳定性**，相同的两个数，不需要交换，所以是稳定的。



### 选择排序

选择未排列数组中的最值，然后放到有序排序时的位置，重复。

**时间复杂度**，最好最坏都是O(n^2)。

**稳定性**，选择排序使用交换的方式来放置最值，会破话相同数的顺序，比如 5  5 2 ，第一个 5 会与 2 交换。



### 插入排序

过程就是将未排列数组中的数插入已经排好的数组。

处理插入的方式有几种。

1. 从未排列数组中取一个数a，a 从有序数组的末尾比较，直到遇到它大于的数 b ，然后把有序数组从b 以后的数向后移动，把 a 插入 b 后边。
2. 同样取数 a ，上一种是比较完再移动，这种是边比较边移动，将 a 存入，临时变量，然后从有序数组末尾开始，如果末尾大于数a，那就a 所在的位置赋值为 末尾的值，然后比较末尾下一位，重复，直到遇到比a小的数。
3. 上一种是用临时变量，这种也是边比较边移动，用交换替代了临时变量。

**时间复杂度**，最坏是O(n^2)，最好是 O(n)，同样是有序的时候。



### 归并排序

现将数组分为多个子数组，直到单个元素的数组，然后合并直到还原成有序数组。

递归划分数组，主要部分在合并有序数组。 

一种方法是用临时数组将两个有序数组比较放入，直到一个数组结束，将另一个数组的后半部分添加到有序数组，另一种是类似插入排序。

**时间复杂度**，最好最坏都是 O(nlogn)

稳定性，是稳定的。在合并的过程中，要注意不破坏。



### 快速排序

基本思想是分治，每次取一个基数，划分数组，左边小于，右边大于。

不同方法实现的区分在于基数划分数组。

单向向右，以最右为基准，两个指针，i 和 j，i 表示第一个大于基准的数，j 表示最后一个大于基准的数，j从左到右，遇到一个比基准小的数，与 i 所指的数交换，i +1，j到最右的时候，基准与 i 所指的数交换，返回基准下标。

双向，i 和 j，以最左为基准，i 在左，j 在右，必须 j 先从右向左开始，找到一个比基准大的数，然后 i 从左往右开始找一个比基准小的数，交换，再循环，直到 i 和 j 相遇，与基准交换，返回 i。

另一种双向，是直接赋值，用临时变量保存基准，i 开始指向基准，j 从右向左找到第一个大于基准的数，与i所指交换，重复，每次都会覆盖一个值，直到i和j相遇，把基准赋值给这个位置。

时间复杂度，最好是 O(nlogn)，最坏的时候是数组有序或数字相同的时候，为O(n^2)



### 希尔排序

按增量将数组分为多个字数组，排列子数组，然后缩小增量，重复。

一般排列子数组选择插入排序。



### 堆排序

堆排序主要是建立一个最大堆或这最小堆，每次删除根节点，然后重新调整堆。

所以主要的实现是建立堆和调整堆。

调整一个子堆，从最后一个非叶子节点开始，将子堆根节点换为子堆中的最小值，然后往前推一个非叶子节点，继续调整，直到堆的根节点，如果子堆被破坏了要重新调整。可以用递归或者循环。

**时间复杂度** 最好最坏都是 O(nlogn)



### 计数排序

需要 max -min +1 个桶，遍历数组，每有一个数等于桶的下标，桶的值加一，遍历结束之后，遍历桶，桶的值不是 0，就输出下标。



### 桶排序

按照某种划分规则，划分出多个桶，按照规则把数放入桶中，然后对桶中的数排序，然后输出。

一般使用链桶法，每个桶都用链表存储，在把桶放入时就用排列好，结束时输出不为空的链表。

计数排序可以看做是特殊的桶排序。



### 基数排序

每次对数的一位排序，从个位开始，直到最大数的最高位。

每次排序，需要10个桶，表示 0 -9，先计算桶的值，然后从第二项开始，每一个桶+=前一个桶，就能得到每个数的位置，然后把数放入临时数组，最后拷贝。

